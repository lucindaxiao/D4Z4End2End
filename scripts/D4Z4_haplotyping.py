# D4Z4End2End haplotyping pipeline
# usage: python2 D4Z4_haplotyping.py -i [input reads (fastq/fasta)] -o [output directory]

import os
import sys
import argparse
import itertools
import re
import collections

import argparse

parser = argparse.ArgumentParser(description='Process some inputs')

parser.add_argument('-o', '--output', type=str, default='D4Z4_haplotyping', help='Output directory (default: D4Z4_haplotyping)')
parser.add_argument('-i', '--input', type=str, help='input reads (fastq/fasta)')
args = parser.parse_args()

out_dir = os.path.join("output", args.output)
reads_file = args.input

if os.path.exists(out_dir):
    print("Warning: An output directory with the same name already exists. Please provide a different name using the '-o' or '--output' argument.")
    sys.exit(1)

os.makedirs(out_dir)

def detect_file_format(file_path):
    with open(file_path, 'r') as file:
        first_line = file.readline().strip()
        if first_line.startswith('>'):
            return 'fasta'
        elif first_line.startswith('@'):
            return 'fastq'
        else:
            raise ValueError("File format not recognised as FASTA or FASTQ.")

file_format = detect_file_format(reads_file)

if os.path.exists("./reference_sequences/CHM13v2.0_chr4.fa.gz"):
    os.system("gunzip ./reference_sequences/CHM13v2.0_chr4.fa.gz")
if os.path.exists("./reference_sequences/CHM13v2.0_chr10.fa.gz"):
    os.system("gunzip ./reference_sequences/CHM13v2.0_chr10.fa.gz")
if not os.path.exists("./reference_sequences/CHM13v2.0_chr4_chr10.fa"):
    os.system("cat ./reference_sequences/CHM13v2.0_chr4.fa ./reference_sequences/CHM13v2.0_chr10.fa > ./reference_sequences/CHM13v2.0_chr4_chr10.fa")
    os.system("rm ./reference_sequences/CHM13v2.0_chr4.fa")
    os.system("rm ./reference_sequences/CHM13v2.0_chr10.fa")

D4Z4_ref_fasta = "./reference_sequences/D4Z4_KnpI.fa"
p13E_11_ref_fasta = "./reference_sequences/p13E11.fa"
pLAM_ref_fasta = "./reference_sequences/pLAM.fa"
B_specific_fasta = "./reference_sequences/4qB_down.fa"
DUX4_ref_fasta = "./reference_sequences/DUX4_mRNA.fa"
chm13_ref_fasta = "./reference_sequences/CHM13v2.0_chr4_chr10.fa"

beta_sat_repeat_unit = "GATCAGTGCAGAGATATGTCACAAAGCCCCTGTAGGCAGAGCCTAGACAAGAGTTACATCACCTGGGT"
telomeric_repeat_unit = "TTAGGG"
PAS_4qA = "GATATATTAAA"
PAS_10qA = "GATATATCAAA"

## initialising dictionaries and lists

reads_characteristics = {}
reads_with_D4Z4 = []
overall_alignment_characteristics = {}
reads_with_pLAM = []
reads_with_B = []
reads_with_DUX4 = []
reads_with_beta = []
reads_with_p13E11 = []
B_length = {}
number_of_D4Z4_units = {}

characterised_reads_out_file = open(out_dir + "/reads_features.txt","w+")
characterised_reads_out_file.write('%s\n'%("read_name" + "\t" + "start" +"\t"+ "end" + "\t" + "element" + "\t" + "mapq" + "\t" + "strand" + "\t" + "element_len" + "\t" + "read_len" + "\t" + "num_of_units" + "\t" + "ref" + "\t" + "ref_start" + "\t" + "ref_end"))

#########################################################################################
################################## Defining functions ###################################
#########################################################################################

## The haplotyping pipeline annotates raw 4q and 10q reads with their features by using minimap2 to map them against the corresponding reference sequences
## These features include D4Z4 units, DUX4 exons, p13E-11, pLAM, qB-specific sequence, beta satellites, telomeric sequence, XapI and BlnI sites, and 4qA/10qA-specific poly(A) signals

## query_span() finds the start coordinate and length of the feature in the read, using the CIGAR string from the bam file

def query_span(CIGAR_string,strand):

    consume_query = {"M":1,"I":1,"D":0,"N":0,"S":0,"H":0,"P":0,"=":1,"X":1}
    integers = re.findall(r'\d+', CIGAR_string)
    characters = re.findall("[a-zA-Z]+", CIGAR_string)
    start = 1
    query_len = 0
    for i in range(len(integers)):
        if ((i == 0) and (characters[0] == "H" or characters[0] == "S")):
            start = int(integers[0])
        else:
            if (consume_query[characters[i]] == 1):
                query_len = query_len + int(integers[i])
    return [start,query_len]

## characterise_reads() populates the following lists and dictionaries by extracting alignment information from bed files (generated by bamtobed):
    # reads_with_pLAM
    # reads_with_B (reads with qB-specific seq.)
    # B_length (length of B-specific seq. in the read)
    # number_of_D4Z4_units
    # reads_characteristics (contains information about the features found in each read)

def characterise_reads(col_info_file, reads_characterised, feature):

    col_info = open(col_info_file, 'r')

    query_details = {}
    query_name = ""

    for line in col_info:
        query_name = line.rstrip().split('\t')[3]
        if ((feature == "pLAM") and (query_name not in reads_with_pLAM)):
            reads_with_pLAM.append(query_name)
        if ((feature == "p13E-11") and (query_name not in reads_with_p13E11)):
            reads_with_p13E11.append(query_name)
        if ((feature == "DUX4") and (query_name not in reads_with_DUX4)):
            reads_with_DUX4.append(query_name)
        if ((feature == "B_specific") and (query_name not in reads_with_B)):
            reads_with_B.append(query_name)
            B_length[query_name] = int(line.rstrip().split('\t')[2]) - int(line.rstrip().split('\t')[1])
        if ((feature == "D4Z4_unit") and (query_name not in number_of_D4Z4_units)):
            number_of_D4Z4_units[query_name] = 1
        elif ((feature == "D4Z4_unit") and (query_name in number_of_D4Z4_units)):
            number_of_D4Z4_units[query_name] += 1
        if (query_name in query_details):
            query_details[query_name][0].append(line.rstrip().split('\t')[5])
            query_details[query_name][1].append(line.rstrip().split('\t')[4])
            query_details[query_name][2].append(line.rstrip().split('\t')[6])
            query_details[query_name][4].append(line.rstrip().split('\t')[0])
            query_details[query_name][5].append(line.rstrip().split('\t')[1])
            query_details[query_name][6].append(line.rstrip().split('\t')[2])
            query_details[query_name][3] = query_details[query_name][3] + 1
        else:
            query_details[query_name] = [[],[],[],1,[],[],[]]
            query_details[query_name][0].append(line.rstrip().split('\t')[5])
            query_details[query_name][1].append(line.rstrip().split('\t')[4])
            query_details[query_name][2].append(line.rstrip().split('\t')[6])
            query_details[query_name][4].append(line.rstrip().split('\t')[0])
            query_details[query_name][5].append(line.rstrip().split('\t')[1])
            query_details[query_name][6].append(line.rstrip().split('\t')[2])

    col_info.close()

    ## loop to parse each read id from the query_details dictionary and populate the reads_characteristics dictionary

    for query in query_details:
        strands = query_details[query][0]
        mapqs = query_details[query][1]
        CIGAR_strings = query_details[query][2]
        total_units = query_details[query][3]
        refs = query_details[query][4]
        ref_starts = query_details[query][5]
        ref_ends = query_details[query][6]
        for i in range(len(CIGAR_strings)):
            stats = query_span(CIGAR_strings[i],strands[i])
            read_start = stats[0]
            aln_len = stats[1]
            strand = strands[i]
            mapq = mapqs[i]
            ref = refs[i]
            ref_start = ref_starts[i]
            ref_end = ref_ends[i]
            if feature == "DUX4":
                read_start += 1
            if (query in reads_characterised):
                reads_characterised[query][read_start] = [aln_len,feature,strand,mapq,total_units,ref,ref_start,ref_end]
            else:
                reads_characterised[query] = {}
                reads_characterised[query][read_start] = [aln_len,feature,strand,mapq,total_units,ref,ref_start,ref_end]


#########################################################################################
############################ D4Z4 unit detection and counting ###########################
#########################################################################################

# 1. Aligns all the reads to the sequence of one D4Z4 unit
# 2. Converts the bam files to bed files
# 3. Sorts the bed files and uses these to determine the lengths, start positions and end positions of the D4Z4 units in the reads

os.system("minimap2 -t 24 -L -a -x map-ont -B 5 " + D4Z4_ref_fasta + " " + reads_file + "| samtools view -@ 24 -bh -F 4 -o " + out_dir + "/D4Z4_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/D4Z4_aligned.bam > " + out_dir + "/D4Z4_aligned.bed")
os.system("samtools view " + out_dir + "/D4Z4_aligned.bam | cut -f1| sort -k1,1 | uniq > " + out_dir + "/D4Z4_aligned_read_ids.txt")

D4Z4_bed_file = out_dir + "/D4Z4_aligned.bed"

characterise_reads(D4Z4_bed_file, reads_characteristics, "D4Z4_unit")

#########################################################################################
######################### Alignment of D4Z4 reads to CHM13v2.0 ##########################
#########################################################################################

# 1. Extracts reads that align to at least one D4Z4 unit
# 2. Aligns these reads to the CHM13v2.0 assembly (with -splice option)
# 3. Sorts the bam files, indexes them, and then converts them to bed files and fastq/fasta files
# 4. Extracts the reads that align to the 4q35 and 10q26 regions of the CHM13v2.0 assembly
# 5. Populates the reads_with_D4Z4_4q and reads_with_D4Z4_10q lists with the relevant read ids

if file_format == "fasta":
    D4Z4_aligned_reads="/D4Z4_aligned_reads.fasta"
elif file_format == "fastq":
    D4Z4_aligned_reads="/D4Z4_aligned_reads.fastq"

os.system("seqtk subseq " + reads_file + " " + out_dir + "/D4Z4_aligned_read_ids.txt > " + out_dir + D4Z4_aligned_reads)
os.system("minimap2 -t 24 -L -a -x splice " + chm13_ref_fasta + " " + out_dir + D4Z4_aligned_reads + " | samtools view -@ 24 -bh -F 2304 | samtools sort -@ 24 -o " + out_dir + "/chm13_aligned.bam -O BAM")
os.system("samtools index " + out_dir + "/chm13_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/chm13_aligned.bam > " + out_dir + "/chm13_aligned.bed")

os.system("samtools view -h " + out_dir + "/chm13_aligned.bam \"chr4:193433000-193574945\" | samtools view | cut -f1 | sort -k1,1 | uniq > " + out_dir + "/chm13_4q_reads.txt")
if file_format == "fasta":
    os.system("seqtk subseq " + out_dir + D4Z4_aligned_reads + " " + out_dir + "/chm13_4q_reads.txt > " + out_dir + "/chm13_4q_reads.fasta" )
elif file_format == "fastq":
    os.system("seqtk subseq " + out_dir + D4Z4_aligned_reads + " " + out_dir + "/chm13_4q_reads.txt > " + out_dir + "/chm13_4q_reads.fastq" )
    os.system("seqtk seq -a " + out_dir + "/chm13_4q_reads.fastq > " + out_dir + "/chm13_4q_reads.fasta")

os.system("samtools view -h " + out_dir + "/chm13_aligned.bam \"chr10:134614000-134758134\" | samtools view | cut -f1 | sort -k1,1 | uniq > " + out_dir + "/chm13_10q_reads.txt")
if file_format == "fasta":
    os.system("seqtk subseq " + out_dir + D4Z4_aligned_reads + " " + out_dir + "/chm13_10q_reads.txt > " + out_dir + "/chm13_10q_reads.fasta" )
elif file_format == "fastq":
    os.system("seqtk subseq " + out_dir + D4Z4_aligned_reads + " " + out_dir + "/chm13_10q_reads.txt > " + out_dir + "/chm13_10q_reads.fastq" )
    os.system("seqtk seq -a " + out_dir + "/chm13_10q_reads.fastq > " + out_dir + "/chm13_10q_reads.fasta")

chm13_4q_read_ids = open(out_dir + "/chm13_4q_reads.txt", 'r')
data = chm13_4q_read_ids.read()
reads_with_D4Z4_4q = data.split("\n")
chm13_4q_read_ids.close()

chm13_10q_read_ids = open(out_dir + "/chm13_10q_reads.txt", 'r')
data = chm13_10q_read_ids.read()
reads_with_D4Z4_10q = data.split("\n")
chm13_4q_read_ids.close()

#########################################################################################
############## p13E-11, DUX4, pLAM, qB-sequence detection and counting ##################
#########################################################################################

# 1. Aligns D4Z4-containing reads to the feature reference sequence
# 2. Converts the bam files to bed files
# 3. Sorts the bed files and use them to determine the lengths, start positions and end positions of the feature in the D4Z4-containing reads

# p13E-11

os.system("minimap2 -t 24 -L -a -x map-ont " + p13E_11_ref_fasta + " " + out_dir + D4Z4_aligned_reads + " | samtools view -@ 24 -bh -F 2304 -o " + out_dir + "/p13E-11_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/p13E-11_aligned.bam > " + out_dir + "/p13E-11_aligned.bed")
p13E_11_bed_file = out_dir + "/p13E-11_aligned.bed"
characterise_reads(p13E_11_bed_file, reads_characteristics, "p13E-11")

# DUX4

os.system("minimap2 -t 24 -L -a -x map-ont " + DUX4_ref_fasta + " " + out_dir + D4Z4_aligned_reads + " | samtools view -@ 24 -bh -F 4 -o " + out_dir + "/DUX4_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/DUX4_aligned.bam > " + out_dir + "/DUX4_aligned.bed")
DUX4_bed_file = out_dir + "/DUX4_aligned.bed"
characterise_reads(DUX4_bed_file, reads_characteristics, "DUX4")

# pLAM

os.system("minimap2 -t 24 -L -a -x map-ont " + pLAM_ref_fasta + " " + out_dir + D4Z4_aligned_reads + " | samtools view -@ 24 -bh -q 50 -e 'rlen > 100' -o " + out_dir + "/pLAM_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/pLAM_aligned.bam > " + out_dir + "/pLAM_aligned.bed")
pLAM_bed_file = out_dir + "/pLAM_aligned.bed"
characterise_reads(pLAM_bed_file, reads_characteristics,"pLAM")

# qB-specific sequence
# (only includes alignments to qB-specific sequence with length > 2000 (rlen > 2000) to ensure specificity for the D4Z4-distal qB region)

os.system("minimap2 -t 24 -L -a -x map-ont " + B_specific_fasta + " " + out_dir + D4Z4_aligned_reads + " | samtools view -@ 24 -bh -q 50 -e 'rlen > 2000' -o " + out_dir + "/4qB_down_aligned.bam")
os.system("bedtools bamtobed -cigar -i " + out_dir + "/4qB_down_aligned.bam > " + out_dir + "/4qB_down_aligned.bed")
B_specific_bed_file = out_dir + "/4qB_down_aligned.bed"
characterise_reads(B_specific_bed_file, reads_characteristics,"B_specific")

# #########################################################################################
# ####################### beta_sat and telomere seq detection and counting ################
# #########################################################################################

# Uses NCRF to find beta satellite and telomere sequences in the D4Z4-containing reads

ncrf_path = os.path.dirname(os.popen("which ncrf").read().strip())
os.environ["ncrf_path"] = ncrf_path

os.system("cat " + out_dir + "/chm13_4q_reads.fasta | NCRF --minmratio=0.70 --minlength=150 " + beta_sat_repeat_unit +  " > " + out_dir + "/4q_beta_sat.ncrf")
os.system("python2 " + ncrf_path + "/ncrf_cat.py " + out_dir + "/4q_beta_sat.ncrf | python2 " + ncrf_path + "/ncrf_summary.py > " + out_dir + "/4q_beta_sat.summary")

os.system("cat " + out_dir + "/chm13_10q_reads.fasta | NCRF --minmratio=0.70 --minlength=150 " + beta_sat_repeat_unit +  " > " + out_dir + "/10q_beta_sat.ncrf")
os.system("python2 " + ncrf_path + "/ncrf_cat.py " + out_dir + "/10q_beta_sat.ncrf | python2 " + ncrf_path + "/ncrf_summary.py > " + out_dir + "/10q_beta_sat.summary")

os.system ("cat " + out_dir + "/4q_beta_sat.summary " + out_dir + "/10q_beta_sat.summary > " + out_dir + "/beta_sat.summary")
os.system("rm " + out_dir + "/4q_beta_sat.summary " + out_dir + "/10q_beta_sat.summary")

beta_sat_bed_file = out_dir + "/beta_sat.summary"

beta_col_info = open(beta_sat_bed_file , 'r')

query_name = ""

for line in beta_col_info:
    query_name = line.rstrip().split('\t')[2]
    if query_name not in reads_with_beta:
        reads_with_beta.append(query_name)

os.system("cat " + out_dir + "/chm13_4q_reads.fasta | NCRF " + telomeric_repeat_unit +  " > " + out_dir + "/4q_telomere.ncrf")
os.system("python2 " + ncrf_path + "/ncrf_cat.py " + out_dir + "/4q_telomere.ncrf | python2 " + ncrf_path + "/ncrf_summary.py > " + out_dir + "/4q_telomere.summary")

os.system("cat " + out_dir + "/chm13_10q_reads.fasta | NCRF " + telomeric_repeat_unit +  " > " + out_dir + "/10q_telomere.ncrf")
os.system("python2 " + ncrf_path + "/ncrf_cat.py " + out_dir + "/10q_telomere.ncrf | python2 " + ncrf_path + "/ncrf_summary.py > " + out_dir + "/10q_telomere.summary")

os.system ("cat " + out_dir + "/4q_telomere.summary " + out_dir + "/10q_telomere.summary > " + out_dir + "/telomere.summary")
os.system("rm " + out_dir + "/4q_telomere.summary " + out_dir + "/10q_telomere.summary")

telomere_bed_file = out_dir + "/telomere.summary"

#########################################################################################
###########################    Calculating read lengths   ###############################
##########################  Detecting XapI and BlnI sites  ##############################
######################  Detecting 4qA- and 10qA-specific pLAM  ##########################
#########################################################################################

# Calculates read lengths
# Searches for exact matches for XapI and BlnI restriction sites within the D4Z4 array for each read
# Searches for exact matches for 4qA- and 10qA-specific poly(A) signals within each read

D4Z4_entries = open(out_dir + D4Z4_aligned_reads, 'r')

i = 0
read_name = ""
read_lengths = {}

for line in D4Z4_entries:
    i += 1
    if file_format == "fasta":
        condition_1 = (i%2 == 1)
        condition_2 = (i%2 == 0)
    elif file_format == "fastq":
        condition_1 = (i%4 == 1)
        condition_2 = (i%4 == 2)
    if ((i >=1) and condition_1):
        identifier = line.rstrip().split(' ')[0]
        read_name = identifier[1:len(identifier)]
        if (read_name not in number_of_D4Z4_units):
            number_of_D4Z4_units[read_name] = 0
    elif ((i >=1) and condition_2):
        read_seq = line.rstrip()
        read_lengths[read_name] = len(read_seq)
        if read_name in reads_characteristics.copy():
            for start in reads_characteristics[read_name].copy():
                if ('D4Z4_unit' in reads_characteristics[read_name][start]):
                    reads_with_D4Z4.append(read_name)
                    BlnI_starts = [m.start()+1 for m in re.finditer('CCTAGG', read_seq)]
                    XapI_starts1 = [m.start()+1 for m in re.finditer('AAATTC', read_seq)]
                    XapI_starts2 = [m.start()+1 for m in re.finditer('AAATTT', read_seq)]
                    XapI_starts3 = [m.start()+1 for m in re.finditer('GAATTC', read_seq)]
                    XapI_starts4 = [m.start()+1 for m in re.finditer('GAATTT', read_seq)]
                    XapI_starts = XapI_starts1 + XapI_starts2 + XapI_starts3 + XapI_starts4
                    PAS_4qA_starts = [m.start()+1 for m in re.finditer(PAS_4qA, read_seq)]
                    PAS_10qA_starts = [m.start()+1 for m in re.finditer(PAS_10qA, read_seq)]
                    aligned_regions = []
                    for start in reads_characteristics[read_name]:
                        if 'D4Z4_unit' in reads_characteristics[read_name][start]:
                            aln_len = reads_characteristics[read_name][start][0]
                            strand = reads_characteristics[read_name][start][2]
                            if strand == '+':
                                aligned_regions.append((start, start + aln_len))
                            else:
                                aligned_regions.append((read_lengths[read_name] - aln_len - start, read_lengths[read_name] - start))

                    def is_within_aligned_regions(position, aligned_regions):
                        for region_start, region_end in aligned_regions:
                            if region_start <= position <= region_end:
                                return True
                        return False

                    for BlnI_start in BlnI_starts:
                        if (BlnI_start not in reads_characteristics[read_name].copy()) and is_within_aligned_regions(BlnI_start, aligned_regions):
                            reads_characteristics[read_name][BlnI_start] = [6,"BlnI","*","*",len(BlnI_starts),"*","*","*"]
                    for XapI_start in XapI_starts:
                        if (XapI_start not in reads_characteristics[read_name].copy()) and is_within_aligned_regions(XapI_start, aligned_regions):
                            reads_characteristics[read_name][XapI_start] = [6,"XapI","*","*",len(XapI_starts),"*","*","*"]
                    for PAS_4qA_start in PAS_4qA_starts:
                        if (PAS_4qA_start not in reads_characteristics[read_name].copy()):
                            reads_characteristics[read_name][PAS_4qA_start] = [11,"PAS_4qA","*","*",len(PAS_4qA_starts),"*","*","*"]
                    for PAS_10qA_start in PAS_10qA_starts:
                        if (PAS_10qA_start not in reads_characteristics[read_name].copy()):
                            reads_characteristics[read_name][PAS_10qA_start] = [11,"PAS_10qA","*","*",len(PAS_10qA_starts),"*","*","*"]
                    break

D4Z4_entries.close()

#########################################################################################
############## Sorting the features and writing to reads_features.txt  ##################
#########################################################################################

# Sorts the reads and their features based on their location in the read, and uses this to generate the read_features.txt file
# Each row in the file is an feature that is present in the read, with the following columns:
# 1) read_id
# 2) start (start position of the feature in the read)
# 3) end (end position of the feature in the read)
# 4) feature (feature name)
# 5) mapq (mapping quality of the alignment)
# 6) strand (direction of the feature in the read (+ or -))
# 7) element_len (length of the feature in the read)
# 8) read_len (total length of the read)
# 9) number_of_units (number of times the feature is found in the read)
# 10) ref (id of the feature reference sequence)
# 11) ref_start (start position within the feature reference sequence for the alignment)
# 12) ref_end (end position within the feature reference sequence for the alignment)

for read_name in reads_characteristics:
    feature_starts = reads_characteristics[read_name].items()
    sorted_feature_starts = sorted(feature_starts)
    for feature_start in sorted_feature_starts:
        strand = feature_start[1][2]
        element_len = feature_start[1][0]
        if (strand == "+"):
            start = feature_start[0]
            end = start + element_len
        elif (strand == '-'):
            start = read_lengths[read_name] - feature_start[0] - element_len
            end = read_lengths[read_name] - feature_start[0]
        elif (strand == "*"):
            start = feature_start[0]
            end = start + element_len
        feature = feature_start[1][1]
        mapq = feature_start[1][3]
        total_units = feature_start[1][4]
        ref = feature_start[1][5]
        ref_start = feature_start[1][6]
        ref_end = feature_start[1][7]
        characterised_reads_out_file.write('%s\n'%(read_name + "\t" + str(start) +"\t"+ str(end) + "\t" + feature + "\t" + str(mapq) + "\t" + strand + "\t" + str(element_len) + "\t" + str(read_lengths[read_name]) + "\t" + str(total_units) + "\t" + ref + "\t" + str(ref_start) + "\t" + str(ref_end)))

beta_sats = open(beta_sat_bed_file, 'r')
total_beta_sat = 0
for line in beta_sats:
    if (line.rstrip()[0] != "#"):
        total_beta_sat += 1
        entries = line.rstrip().split('\t')
        feature = "beta_sat"
        strand = entries[5]
        read_name = entries[2]
        if (read_name in reads_characteristics):
            feature_starts = list(reads_characteristics[read_name].items())
            if len(feature_starts) > 1 and len(feature_starts[1][1]) > 7:
                ref = feature_starts[1][1][5]
                ref_start = feature_starts[1][1][6]
                ref_end = feature_starts[1][1][7]
            ref = "beta"
        else:
            ref = "*"
            ref_start = "*"
            ref_end = "*"
        read_length = entries[6]
        start = entries[3]
        end = entries[4]
        element_len = int(end) - int(start)
        characterised_reads_out_file.write('%s\n'%(read_name + "\t" + str(start) +"\t"+ str(end) + "\t" + feature + "\t" +  "NA" + "\t" + strand + "\t" + str(element_len) + "\t" + str(read_length) + "\t" + str(total_beta_sat) + "\t" + ref + "\t" + str(ref_start) + "\t" + str(ref_end)))

beta_sats.close()

telomeres = open(telomere_bed_file, 'r')
total_telomeres = 0
for line in telomeres:
    if (line.rstrip()[0] != "#"):
        total_telomeres += 1
        entries = line.rstrip().split('\t')
        feature = "Telomere"
        strand = entries[5]
        read_name = entries[2]
        if (read_name in reads_characteristics):
            feature_starts = list(reads_characteristics[read_name].items())
            if len(feature_starts) > 1 and len(feature_starts[1][1]) > 7:
                ref = feature_starts[1][1][5]
                ref_start = feature_starts[1][1][6]
                ref_end = feature_starts[1][1][7]
        else:
            ref = "*"
            ref_start = "*"
            ref_end = "*"
        read_length = entries[6]
        start = entries[3]
        end = entries[4]
        element_len = int(end) - int(start)
        characterised_reads_out_file.write('%s\n'%(read_name + "\t" + str(start) +"\t"+ str(end) + "\t" + feature + "\t" +  "NA" + "\t" + strand + "\t" + str(element_len) + "\t" + str(read_length) + "\t" + str(total_beta_sat) + "\t" + ref + "\t" + str(ref_start) + "\t" + str(ref_end)))

telomeres.close()

characterised_reads_out_file.close()

#########################################################################################
######################################## Haplotyping ####################################
#########################################################################################

# Determines if the read is A-type/B-type based on the presence/absence of pLAM/beta-sat sequence and qB-specific sequence respectively
# Determines if the read spans the entire D4Z4 array
# Uses this to generate the haplotypes.txt file containing the following columns:
# 1) read id
# 2) haplotype (4q/10q/4qA/10qA - classified as 4q/10q if there is no pLAM/beta-sat or qB-specific sequence)
# 3) number of D4Z4 units
# 4) spanning (whether the read spans the entire D4Z4 array)
# 5) chromosome (chr4/chr10)
# 6) ranges (section of the read that aligned to the CHM13v2.0 assembly)
# 7) strand relative to CHM13v2.0 (+/-)

chm13_bed = open(out_dir + "/chm13_aligned.bed", 'r')

for line in chm13_bed:
    read_id = line.rstrip().split('\t')[3]
    chromosome = line.rstrip().split('\t')[0]
    ref_start = int(line.rstrip().split('\t')[1])
    ref_end = int(line.rstrip().split('\t')[2])
    mapq = line.rstrip().split('\t')[4]
    strand = line.rstrip().split('\t')[5]
    cigar = line.rstrip().split('\t')[6]
    read_start_end = query_span(cigar,strand)
    if (strand == "+"):
        read_start = int(read_start_end[0])
        read_end = int(read_start) + int(read_start_end[1])
    elif (strand == "-"):
        read_start = read_lengths[read_id] - int(read_start_end[0]) - int(read_start_end[1])
        read_end = int(read_start) + int(read_start_end[1])
    else:
        read_start = "*"
        read_end = "*"
    
    entire_array = "no"
    if (((read_id in reads_with_D4Z4_4q) or (read_id in reads_with_D4Z4_10q)) and (read_id in reads_with_p13E11) and ((read_id in reads_with_pLAM) or (read_id in reads_with_beta) or (read_id in reads_with_B))):
        entire_array = "yes"

    if read_id not in overall_alignment_characteristics:
        overall_alignment_characteristics[read_id] = []
    overall_alignment_characteristics[read_id].append([chromosome,ref_start,ref_end,mapq,strand,read_start,read_end,entire_array])

haplotypes = {}
for read_id in number_of_D4Z4_units:
    if ((read_id in overall_alignment_characteristics) and (len(overall_alignment_characteristics[read_id]) == 1)):

        alignment = overall_alignment_characteristics[read_id]

        if ((alignment[0][0] == "chr10") and (alignment[0][7] == "yes") and (read_id in reads_with_B)):
            haplotypes[read_id] = ["10qB", number_of_D4Z4_units[read_id], "yes"]
        if ((alignment[0][0] == "chr10") and (alignment[0][7] == "yes") and ((read_id in reads_with_pLAM) or (read_id in reads_with_beta))):
            haplotypes[read_id] = ["10qA", number_of_D4Z4_units[read_id], "yes"]
        if ((alignment[0][0] == "chr10") and (alignment[0][7] == "no") and ((read_id in reads_with_pLAM) or (read_id in reads_with_beta))):
            haplotypes[read_id] = ["10qA", number_of_D4Z4_units[read_id], "no"]
        if ((alignment[0][0] == "chr10") and (alignment[0][7] == "no") and (read_id in reads_with_B)):
            haplotypes[read_id] = ["10qB", number_of_D4Z4_units[read_id], "no"]
        if ((alignment[0][0] == "chr10") and (alignment[0][7] == "no") and ((read_id not in reads_with_pLAM) and (read_id not in reads_with_beta) and (read_id not in reads_with_B))):
            haplotypes[read_id] = ["10q", number_of_D4Z4_units[read_id], "no"]

        if ((alignment[0][0] == "chr4") and (alignment[0][7] == "yes") and (read_id in reads_with_B)):
            haplotypes[read_id] = ["4qB", number_of_D4Z4_units[read_id], "yes"]
        if ((alignment[0][0] == "chr4") and (alignment[0][7] == "yes") and ((read_id in reads_with_pLAM) or (read_id in reads_with_beta))):
            haplotypes[read_id] = ["4qA", number_of_D4Z4_units[read_id], "yes"]
        if ((alignment[0][0] == "chr4") and (alignment[0][7] == "no") and ((read_id in reads_with_pLAM) or (read_id in reads_with_beta))):
            haplotypes[read_id] = ["4qA", number_of_D4Z4_units[read_id], "no"]
        if ((alignment[0][0] == "chr4") and (alignment[0][7] == "no") and (read_id in reads_with_B)):
            haplotypes[read_id] = ["4qB", number_of_D4Z4_units[read_id], "no"]
        if ((alignment[0][0] == "chr4") and (alignment[0][7] == "no") and ((read_id not in reads_with_pLAM) and (read_id not in reads_with_beta) and (read_id not in reads_with_B))):
            haplotypes[read_id] = ["4q", number_of_D4Z4_units[read_id], "no"]
    
    if ((read_id in overall_alignment_characteristics) and (read_id in haplotypes)):
        chr_id = []
        read_range = []
        strand = []
        for entry in overall_alignment_characteristics[read_id]:
            chr_id.append(entry[0])
            read_range.append(str(entry[5]) + "-" + str(entry[6]))
            strand.append(entry[4])
        haplotypes[read_id].append(','.join(chr_id))
        haplotypes[read_id].append(','.join(read_range))
        haplotypes[read_id].append(','.join(strand))

chm13_bed.close()
haplotypes_file = open(out_dir + "/haplotypes.txt",'w+')
haplotypes_file.write('%s\n'%("read_id\thaplotype\tD4Z4_units\tspanning\tchromosome\tranges\tstrand"))
for read_id in haplotypes:
    print_string = read_id
    for element in haplotypes[read_id]:
        print_string = print_string + "\t" + str(element)
    haplotypes_file.write('%s\n'%(print_string))

haplotypes_file.close()

os.system("cp haplotypes.html " + out_dir)